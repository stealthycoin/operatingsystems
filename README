Untar, enter the directory, become root, and then run "install.sh". This script will copy the relevant files to their proper locations under "/usr/src" and then will run "make clean install" in the "/usr/src/tools" directory. After this finishes restart minix and select option 2: the custom version of minix. Once you have logged back in return to the uncompressed directory (where "install.sh" was located) and enter "tests". First run "make" to compile the CPU bound and IO bound executables and then proceed to execute "test_N.sh" for N=1,2,3,4,5. See the table below for what each of these scripts demonstrates:

Script       Property of Scheduler 
"test_1.sh"  Show that running two equal CPU bound tasks with equal tickets lets them run at about the same speed
"test_2.sh"  Show that running two CPU tasks where 1 has twice the tickets, the task with more tickets finishes in 1/2 the time 
"test_3.sh"  Show that running three CPU tasks with 25, 50, and 100 tickets runs the tasks in the right ratio 
"test_4.sh"  Show that running several CPU tasks with 100 tickets doesn't completely starve another task with just 1 ticket 
"test_5.sh"  Show that your dynamic scheduler improves performance when you mix CPU and IO bound tasks compared to keeping a fixed number of tickets for each process (run this one both with the static scheduler and the dynamic scheduler and observe the difference)

If you wish to install the dynamic version of the scheduler then before running "install.sh" edit the file "servers/sched/sched.h" and change the macro "DYNAMIC" to the value 1 (setting this to zero yields a static lottery scheduler). We show that ``our dynamic scheduler actually does dynamically adjust tickets of processes'' with a print statement in "do_noquantum". As long as the dynamic lotter scheduler is in place and there are CPU bound processes, you will see messages indicating when a ticket have been taken and which endpoint it has been taken from.

Note that all of the test_N.sh scripts are tunable. If your install of minix is significantly faster or slower for some reason (more or less mem/underlying hardware) you should edit the numbers that are presented at the end of each line as follows:

time nice -n 80 ./cpu_bound 10

becomes:

time nice -n 80 ./cpu_bound 100

this will make it take 10 times longer.

For test_5.sh the IO_bound process' time is dependant on the size of the input file. This input file is created in the Makefile with:

dd if=/dev/urandom of=IO_bound.in count=50000

This was optimized to take 5 seconds, but as above the number following 'count=' may be scaled to see a linear speed up/slowdown.
